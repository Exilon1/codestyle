```java
var random = new Random(INIT_VALUE);
        ...
var concatenatedString = "";
        ...
var report = getDafaultReport();
```
Неявное объявление переменных внутри методов доступно в Java 11 и выше. Заменяем слово var на типы Random, String, Report.

---
Калькулятор выражения в обратной польской нотации использует прямой и обратный стек.
```java
private static InvertedStack<Object> expressionStack = new InvertedStack<>();
private static Stack<Integer> resultStack = new Stack<>();
```
Известно, что переменной resultStack значение присваивается единожды и не будет меняться, присваиваем ему модификатор final.

---
Из примера выше инициализацию resultStack выносим в конструктор.

---
Из примера выше инициализацию expressionStack выносим в в метод ленивой инициализации `initializeExpressionStack(String expression)`, кторый будет использоваться повтороно всякий раз, когда требуется вычислить новое выражение.

---
`private Integer result = null;`
Переменная result используется только внутри одного метода. Переносим её туда.

---
LinkedList, операция удаления ноды `void removeNode(Node node)`. В конце после после простановки предыдущей и следующей у крайних нод необходимо у самой удалённой ноды проставить null
```java
    node.prev = null;
    node.next = null;
```

---
В DynamicArray функция очистки помимо пересоздания массива должна содержать выполнять count = 0. В противном случае использование `clean()` приведёт к ошибке.

---
Если в реализации Хэш Таблицы индекс-указатель является состоянием объекта, присваиваем ему -1 в конце начале или конце каждой операции, работающей с этим индексом.

---
Реализация Хэш Таблицы, метод `seekSlot()`
```java
int count = 0;

    while (slots[index] != null && count < size) {
        count++;
```
Мееняем цикл на for. count заменяем на i вутри for. count не является накопителем внутри цикла.

---
Обновление аккумулятора перед использованием в цикле требуется, если переменная является глобальной.  
Используем только внутренние переменные методов, где это возможно.

---
Вместо цикла `for (int i = 0; i < size; i++)` используем конструкцию foreach  
`for(String s: slots)`  
Делаем это, потому что значение счётчика ни где не используется, но итерируем все элементы массива.

---
Во время разработки используем assert в случаях, когда по в логике исполнения программы в конкретном месте кода исключено любое появления значения, считающегося невозможным.  
assert не является частью бизнес логики и заменой exception.